<!DOCTYPE html>
<meta charset="utf-8">
<style>
    .links line {
        stroke-opacity: 0.6;
    }

    .nodes circle {
        stroke: white;
        stroke-width: 1.5px;
    }

    #controls {
        display: inline-block;
        vertical-align: top;
    }
</style>
<svg width="1200" height="750"></svg>
<div id="controls">
    <button id="startAttack">Start Attack</button>
    <button id="stopAttack">Stop Attack</button>
</div>
<script src="d3.v4.min.js"></script>
<script>
    var svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height");

    var color = v => {
        switch (v) {
         case 1: return 'blue';
         case 2: return 'red';
        }
    }
    var linkColor = v => {
        switch (v) {
         case 1: return '#999';
         case 2: return 'red';
        }
    }

    var simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(function (d) { return d.id; }))
        .force("charge", d3.forceManyBody())
        .force("center", d3.forceCenter(width / 2, height / 2))
        .alphaTarget(1)
        .on("tick", ticked);

    d3.timeout(() => simulation.stop(), 5000);
    let link = svg.append("g").classed('links', true).attr("stroke-width", 1).selectAll(".link");
    let node = svg.append("g").classed('nodes', true).attr("stroke-width", 1.5).selectAll(".node");

    let graph;
    d3.json("adjacency_matrix.json", function (error, data) {
        if (error) throw error;

        graph = getGraph(data);

        draw();
    });

    function draw() {

        link = link
            .data(graph.links, function (d) { return d.source.id + "-" + d.target.id; });
        link.exit().remove();
        link = link.enter().append("line").merge(link);
        link.attr("stroke", function (d) { return linkColor(d.group); })

        node = svg.select('.nodes')
            .selectAll("circle")
            .data(graph.nodes, function (d) { return d.id; });
        node.exit().remove();
        node = node.enter().append("circle").merge(node);
        node.attr("r", 5)
            .attr("fill", function (d) { return color(d.group); })
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended))
            .on("click", d => removeVertex(d, graph));

        node.append("title")
            .text(function (d) { return d.id; });

        simulation
            .nodes(graph.nodes);

        simulation.force("link")
            .links(graph.links);

        simulation.alpha(1);
    }

    function getGraph(data) {
        const graph = {
            nodes: Object.keys(data)
                .map(k => ({
                    id: k,
                    group: 1,
                    degree: data[k].length
                })),
            links: Object.keys(data).map(k => data[k]
                .map(e => ({ 
                    source: k, 
                    target: e, 
                    group: 1
                    })))
                .reduce(function (a, b) {
                    return a.concat(b);
                }, [])
        };
        return graph;
    }

    function ticked() {
        link
            .attr("x1", function (d) { return d.source.x; })
            .attr("y1", function (d) { return d.source.y; })
            .attr("x2", function (d) { return d.target.x; })
            .attr("y2", function (d) { return d.target.y; });

        node
            .attr("cx", function (d) { return d.x; })
            .attr("cy", function (d) { return d.y; });
    }

    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

    function removeVertex(d, graph) {
        var index = graph.nodes.indexOf(d);
        if (index > -1) {
            graph.nodes.splice(index, 1);
        }
        do {
            let i = graph.links.map(l => l.source).indexOf(d);
            if (i === -1)
                i = graph.links.map(l => l.target).indexOf(d);
            if (i === -1)
                break;
            graph.links.splice(i, 1);
        } while (true);
        draw();
    }

    let attackTimer;

    function startAttack() {
        function chooseNode() {
            const maxDegree = d3.max(graph.nodes.map(n => n.degree));
            const n = graph.nodes.find(n => n.degree == maxDegree);
            const ls = graph.links.filter(l => l.source == n || l.target == n);
            n.group = 2;
            ls.forEach(l => l.group = 2);
            return n;
        }
        let nodeToBeRemoved = chooseNode;
        attackTimer = d3.interval(function () {
            removeVertex(nodeToBeRemoved, graph);
            nodeToBeRemoved = chooseNode();
            draw();
            }, 1000, d3.now());
    }

    function stopAttack() {
        attackTimer.stop();
    }

    const buttons = document.querySelectorAll('button');
    buttons.forEach(b => b.addEventListener('click', () => {
        const id = b.id;
        window[id]();
    }));

</script>