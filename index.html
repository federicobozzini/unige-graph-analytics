<!DOCTYPE html>
<meta charset="utf-8">
<style>
    .links line {
        stroke-opacity: 0.6;
    }

    .nodes circle {
        stroke: white;
        stroke-width: 1.5px;
    }

    h4 {
        margin: 0;
        margin-bottom: 2px;
    }

    #info {
        display: inline-block;
        vertical-align: top;
    }

    #controls>div {
        margin-bottom: 20px;
    }

    #controls label {
        display: block;
    }

    #controls button {
        display: block;
        margin-bottom: 10px;
    }
</style>
<svg width="1350" height="750"></svg>
<div id="info">
    <div id="controls">
        <h2>Attack</h2>
        <div>
            <h4>Attack Strategy</h4>
            <label><input type="radio" name="attackParameter" value="degree" checked>Degree</label>
            <label><input type="radio" name="attackParameter" value="clusteringCoefficient">Clustering Coefficient</label>
            <label><input type="radio" name="attackParameter" value="random">Random</label>
        </div>
        <div>
            <button id="startAttack">Start Attack</button>
            <button id="stopAttack">Stop Attack</button>
            <button id="reset">Reset</button>
        </div>
    </div>
    <div id="stats">
        <h2>Stats</h2>
    </div>
</div>
<script src="d3.v4.min.js"></script>
<script>
    var svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height");

    var color = v => {
        switch (v) {
            case 1: return 'blue';
            case 2: return 'red';
        }
    }
    var linkColor = v => {
        switch (v) {
            case 1: return '#aaa';
            case 2: return 'red';
        }
    }

    var simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(function (d) { return d.id; }))
        .force("charge", d3.forceManyBody())
        .force("center", d3.forceCenter(width / 2 - 80, height / 2))
        .alphaTarget(1)
        .on("tick", ticked);

    d3.timeout(() => simulation.stop(), 3500);
    let link = svg.append("g").classed('links', true).attr("stroke-width", 1).selectAll(".link");
    let node = svg.append("g").classed('nodes', true).attr("stroke-width", 1.5).selectAll(".node");

    let graph, rawData, rawDataTmp, stats;
    d3.json("adjacency_matrix.json", function (error, data) {
        if (error) throw error;
        rawData = data;
        reset();
    });

    function reset() {
        rawDataTmp = rawData;
        graph = getGraph(rawData);
        stats = getStats();
        stopAttack();
        simulation.restart();
        d3.timeout(() => simulation.stop(), 3500);
        draw();
    }

    function draw() {

        link = link
            .data(graph.links, function (d) { return d.source.id + "-" + d.target.id; });
        link.exit().remove();
        link = link.enter().append("line").merge(link);
        link.attr("stroke", function (d) { return linkColor(d.group); })

        node = svg.select('.nodes')
            .selectAll("circle")
            .data(graph.nodes, function (d) { return d.id; });
        node.exit().remove();
        node = node.enter().append("circle").merge(node);
        node.attr("r", 5)
            .attr("fill", function (d) { return color(d.group); })
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended))
            .on("click", d => removeVertex(d));

        node.append("title")
            .text(function (d) { return d.id; });

        simulation
            .nodes(graph.nodes);

        simulation.force("link")
            .links(graph.links);

        simulation.alpha(1);

        const statsVis = d3.select('#stats')
            .selectAll('div')
            .data(stats, d => d.label);

        statsVis.exit().remove();
        statsVis.enter().append('div');
        d3.select('#stats')
            .selectAll('div')
            .text(d => d.label + ': ' + d.val);

    }

    function getGraph(data) {
        const graph = {
            nodes: Object.keys(data)
                .map(k => ({
                    id: k,
                    group: 1,
                    degree: data[k].length,
                    clusteringCoefficient: getClusteringCoefficient(k, data),
                    random: Math.random()
                })),
            links: Object.keys(data).map(k => data[k]
                .map(e => ({
                    source: k,
                    target: e,
                    group: 1
                })))
                .reduce(function (a, b) {
                    return a.concat(b);
                }, [])
        };
        return graph;
    }

    function getClusteringCoefficient(k, data) {
        const neighbors = data[k];
        const n = neighbors.length;
        if (n < 1)
            return 0;
        const connectedNeighbors = neighbors.filter(n => data[n].some(n2 => neighbors.includes(n2))).length;
        return connectedNeighbors / n / (n - 1);
    }

    function ticked() {
        link
            .attr("x1", function (d) { return d.source.x; })
            .attr("y1", function (d) { return d.source.y; })
            .attr("x2", function (d) { return d.target.x; })
            .attr("y2", function (d) { return d.target.y; });

        node
            .attr("cx", function (d) { return d.x; })
            .attr("cy", function (d) { return d.y; });
    }

    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

    function removeVertex(d) {
        var index = graph.nodes.indexOf(d);
        if (index > -1) {
            graph.nodes.splice(index, 1);
        }
        do {
            let i = graph.links.map(l => l.source).indexOf(d);
            if (i === -1)
                i = graph.links.map(l => l.target).indexOf(d);
            if (i === -1)
                break;
            graph.links.splice(i, 1);
        } while (true);
        delete rawDataTmp[d.id];
        Object.values(rawDataTmp).filter(r => r.includes(d.id)).forEach(r => {
            var index = r.indexOf(d.id);
            r.splice(index, 1);
        });
        draw();
    }

    let attackTimer;

    function getOptions() {
        function groupBy(xs, key) {
            return xs.reduce(function (rv, x) {
                (rv[x[key]] = rv[x[key]] || []).push(x);
                return rv;
            }, {});
        };

        const radioButtons = [...document.querySelectorAll('input[type=radio]')];
        const radioGroups = groupBy(radioButtons, 'name');
        const checkboxes = [...document.querySelectorAll('input[type=checkbox]')];
        const options = {};
        Object.keys(radioGroups).forEach(g => {
            const selectedButton = radioGroups[g].find(b => b.checked);
            options[selectedButton.name] = selectedButton.value;
            const dataset = selectedButton.dataset;
        });
        checkboxes.forEach(c => {
            options[c.name] = c.checked;
        });
        return options;
    }

    function startAttack() {
        const options = getOptions();
        const attackParameter = options.attackParameter;
        function chooseNode() {
            const maxVal = d3.max(graph.nodes.map(n => n[attackParameter]));
            const n = graph.nodes.find(n => n[attackParameter] == maxVal);
            const ls = graph.links.filter(l => l.source == n || l.target == n);
            n.group = 2;
            ls.forEach(l => l.group = 2);
            return n;
        }
        let nodeToBeRemoved;
        attackTimer = d3.interval(function () {
            if (nodeToBeRemoved)
                removeVertex(nodeToBeRemoved);
            nodeToBeRemoved = chooseNode();
            stats = getStats();
            draw();
        }, 1000, d3.now());
    }

    function stopAttack() {
        if (attackTimer)
            attackTimer.stop();
    }

    function getStats() {
        const nodes = graph.nodes.length;
        const graph2 = getGraph(rawDataTmp);
        const maxVal = d3.max(graph2.nodes.map(n => n.degree));
        const n = graph2.nodes.find(n => n.degree == maxVal);
        let i = 0;
        const nodesToBeVisited = [n];
        while (nodesToBeVisited.length) {
            let el = null;
            do {
                el = nodesToBeVisited.pop();
            } while (el.visited && nodesToBeVisited.length);
            if (!el)
                break;
            el.visited = true;
            const neighbors = rawDataTmp[el.id];
            i++;
            const neighborsToVisit = neighbors.map(e => graph2.nodes.find(n => n.id == e)).filter(e => !e.visited);
            nodesToBeVisited.push(...neighborsToVisit);
        }
        return [
            { label: 'Number of nodes', val: nodes },
            { label: 'Giant component size', val: i }
        ];
    }

    const buttons = document.querySelectorAll('button');
    buttons.forEach(b => b.addEventListener('click', () => {
        const id = b.id;
        window[id]();
    }));

</script>