<!DOCTYPE html>
<meta charset="utf-8">
<style>
    .links line {
        stroke-opacity: 0.6;
    }

    .nodes circle {
        stroke: white;
        stroke-width: 1.5px;
    }

    h4 {
        margin: 0;
        margin-bottom: 2px;
    }

    #info {
        display: inline-block;
        vertical-align: top;
    }

    .controls>div {
        margin-bottom: 20px;
    }

    .controls label {
        display: block;
        margin-bottom: 4px;
    }

    .controls button {
        display: block;
        margin-bottom: 10px;
        width: 150px;
    }

    #stats {
        min-height: 120px;
    }

    input[type=text] {
        width: 20px;
    }

    #info label span {
        display: inline-block;
        width: 120px;
    }

    .status {
        font-weight: bold;
    }
</style>
<svg width="1260" height="750"></svg>
<div id="info">
    <h2>Control Panel</h2>
    <div class="controls">
        <div>
            <h4>Contagion initialization</h4>
            <label><span>Infected nodes:</span><input type="text" name="k" value="66" checked></label>
            <label><span>Option 1 payoff:</span><input type="text" name="payoff1" value="1" checked></label>
            <label><span>Option 2 payoff:</span><input type="text" name="payoff2" value="2.9" checked></label>
            <h4>Other options</h4>
            <label>
                <span>Simulaton speed:</span>
                <select name="speed">
                    <option value="2000">Slow</option>
                    <option value="1000" selected>Medium</option>
                    <option value="500">Fast</option>
                </select>
            </label>
            <label>
                <span>Node selection:</span>
                <select name="attackParameter">
                    <option value="degree"selected>Degree</option>
                    <option value="clusteringCoefficient">Clustering coefficient</option>
                    <option value="random">Random</option>
                </select>
            </label>
        </div>
        <div>
            <button id="startAttack">Start Attack</button>
            <button id="startContagion">Start Contagion</button>
            <button id="stop">Stop</button>
            <button id="reset">Reset</button>
        </div>
    </div>
    <h4 class="status">Status: Loading</h4>
    <div id="stats">
        <h3>Stats</h3>
    </div>
</div>
<script src="d3.v4.min.js"></script>
<script>
    const NORMAL = 1, TO_BE_REMOVED = 2, INFECTED = 3;
    const LOADING = 'Loading', WAITING = 'Wating', ATTACK = 'Attack', CONTAGION = 'Contagion';
    var svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height");

    var color = v => {
        switch (v) {
            case NORMAL: return 'blue';
            case TO_BE_REMOVED: return 'red';
            case INFECTED: return 'orange';
        }
    }
    var linkColor = v => {
        switch (v) {
            case NORMAL: return '#aaa';
            case TO_BE_REMOVED: return 'red';
        }
    }

    let graph, rawData, rawDataTmp, stats, attackTimer, contagionTimer, iteration, status;

    var simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(function (d) { return d.id; }))
        .force("charge", d3.forceManyBody())
        .force("center", d3.forceCenter(width / 2 - 140, height / 2))
        .velocityDecay(0.55)
        // .alphaMin(0.05)
        .on("tick", ticked);

    //d3.timeout(() => simulation.stop(), 4000);
    let link = svg.append("g").classed('links', true).attr("stroke-width", 1).selectAll(".link");
    let node = svg.append("g").classed('nodes', true).attr("stroke-width", 1.5).selectAll(".node");
    
    loadEvents();
    d3.json("adjacency_matrix.json", function (error, data) {
        if (error) throw error;
        rawData = data;
        reset();
    });

    function reset() {
        rawDataTmp = JSON.parse(JSON.stringify(rawData));
        graph = getGraph(rawData);
        iteration = 0;
        stop();
        status = LOADING;
        simulation.restart();
        draw();
        d3.timeout(() => {
            simulation.stop();
            status = WAITING;
            draw();
        }, 3500);
    }

    function getAllControls() {
        return [...document.querySelectorAll('input, select, button')];
    }

    function getControlsToDisable(status) {   
        let componentsToDisableSelector;
        const statusDisablingSelectorMatrix = {
            [LOADING]: 'input, select, button',
            [WAITING]: '#stop',
            [ATTACK]: 'input, select, button:not(#stop)',            
            [CONTAGION]: 'input, select, button:not(#stop)'
        }
        const selector = statusDisablingSelectorMatrix[status];
        if (!selector)
            return [];
        return [...document.querySelectorAll(selector)];
    }

    function draw() {
        stats = getStats();
        const controls = getAllControls();
        controls.forEach(c => c.disabled = false);
        const controlsToDisable = getControlsToDisable(status);
        controlsToDisable.forEach(c => c.disabled = true);

        d3.select('.status').text(d => 'Status: ' + status);

        node = svg.select('.nodes')
            .selectAll("circle")
            .data(graph.nodes, function (d) { return d.id; });
        node.exit().remove();
        node = node.enter().append("circle").merge(node);
        node.attr("r", 4.3)
            .attr("fill", function (d) { return color(d.group); })
            .on('mouseover', d => {
                setNodeToDelete(d);
                draw();
            })
            .on('mouseout', d => {
                setNodeNotToDelete(d);
                draw();
            })
            .on("click", d => {
                removeVertex(d);
                draw();
            });

        link = link
            .data(graph.links, function (d) { return d.source.id + "-" + d.target.id; });
        link.exit().remove();
        link = link.enter().append("line").merge(link);
        link.attr("stroke", function (d) { return linkColor(d.group); });

        node.append("title")
            .text(function (d) { return d.id; });

        simulation
            .nodes(graph.nodes);

        simulation.force("link")
            .links(graph.links);

        simulation.alpha(1);

        const statsVis = d3.select('#stats')
            .selectAll('div')
            .data(stats);

        statsVis.exit().remove();
        statsVis.enter().append('div');
        d3.select('#stats')
            .selectAll('div')
            .text(d => d.label + ': ' + d.val);

    }

    function getGraph(data) {
        const graph = {
            nodes: Object.keys(data)
                .map(k => ({
                    id: k,
                    group: NORMAL,
                    degree: data[k].length,
                    clusteringCoefficient: getClusteringCoefficient(k, data),
                    random: Math.random()
                })),
            links: Object.keys(data).map(k => data[k]
                .map(e => ({
                    source: k,
                    target: e,
                    group: NORMAL
                })))
                .reduce(function (a, b) {
                    return a.concat(b);
                }, [])
        };
        return graph;
    }

    function getClusteringCoefficient(k, data) {
        const neighbors = data[k];
        const n = neighbors.length;
        if (n <= 1)
            return 0;
        const connectedNeighbors = neighbors.filter(n => data[n].some(n2 => neighbors.includes(n2))).length;
        return connectedNeighbors / n / (n - 1);
    }

    function ticked() {
        link
            .attr("x1", function (d) { return d.source.x; })
            .attr("y1", function (d) { return d.source.y; })
            .attr("x2", function (d) { return d.target.x; })
            .attr("y2", function (d) { return d.target.y; });

        node
            .attr("cx", function (d) { return d.x; })
            .attr("cy", function (d) { return d.y; });
    }

    function removeVertex(d) {
        delete rawDataTmp[d.id];
        Object.values(rawDataTmp).filter(r => r.includes(d.id)).forEach(r => {
            var index = r.indexOf(d.id);
            r.splice(index, 1);
        });
        var index = graph.nodes.indexOf(d);
        if (index > -1) {
            graph.nodes.splice(index, 1);
        }
        do {
            let i = graph.links.map(l => l.source).indexOf(d);
            if (i === -1)
                i = graph.links.map(l => l.target).indexOf(d);
            if (i === -1)
                break;
            graph.links.splice(i, 1);
        } while (true);
        graph.nodes.forEach(n => {
            n.degree = rawDataTmp[n.id].length;
            n.clusteringCoefficient = getClusteringCoefficient(n.id, rawDataTmp);
        });
    }

    function getOptions() {
        function groupBy(xs, key) {
            return xs.reduce(function (rv, x) {
                (rv[x[key]] = rv[x[key]] || []).push(x);
                return rv;
            }, {});
        };

        const textInputs = [...document.querySelectorAll('input[type=text]')];
        const radioButtons = [...document.querySelectorAll('input[type=radio]')];
        const radioGroups = groupBy(radioButtons, 'name');
        const checkboxes = [...document.querySelectorAll('input[type=checkbox]')];
        const selectOptions = [...document.querySelectorAll('option')];
        selectOptions.forEach(o => parentName = o.parentNode.name);
        const selectOptionGroups = groupBy(selectOptions, 'parentName');
        const options = {};
        Object.keys(radioGroups).forEach(g => {
            const selectedButton = radioGroups[g].find(b => b.checked);
            options[selectedButton.name] = selectedButton.value;
        });
        checkboxes.forEach(c => {
            options[c.name] = c.checked;
        });
        textInputs.forEach(t => {
            options[t.name] = t.value;
        });
        selectOptions.filter(o => o.selected).forEach(o => {
            options[o.parentNode.name] = o.value;
        })
        return options;
    }

    function setNodeToDelete(n) {
        const ls = graph.links.filter(l => l.source == n || l.target == n);
        n.group = TO_BE_REMOVED;
        ls.forEach(l => l.group = TO_BE_REMOVED);
    }

    function setNodeNotToDelete(n) {
        const ls = graph.links.filter(l => l.source == n || l.target == n);
        n.group = NORMAL;
        ls.forEach(l => l.group = NORMAL);
    }


    function chooseNodes(choiceParameter, k) {
        const maxVal = d3.max(graph.nodes.map(n => n[choiceParameter]));
        const n = graph.nodes.find(n => n[choiceParameter] == maxVal);
        graph.nodes.sort((n1, n2) => n2[choiceParameter] - n1[choiceParameter]);
        return graph.nodes.slice(0, k);
    }

    function cleanAttack() {
        graph.nodes.filter(n => n.group == TO_BE_REMOVED).forEach(n => n.group = NORMAL);
        graph.links.filter(l => l.group == TO_BE_REMOVED).forEach(l => l.group = NORMAL);
    }

    function startAttack() {
        stop();
        cleanAttack();
        status = ATTACK;
        const options = getOptions();
        let nodeToBeRemoved;
        attackTimer = d3.interval(function () {
            iteration++;
            if (nodeToBeRemoved)
                removeVertex(nodeToBeRemoved);
            nodeToBeRemoved = chooseNodes(options.attackParameter, 1)[0];
            setNodeToDelete(nodeToBeRemoved);
            draw();
        }, +options.speed, d3.now());
    }

    function getStats() {
        function sum(xs) {
            return xs.reduce(function (a, b) { return a + b; });
        }
        function avg(xs) {
            return sum(xs) / xs.length;
        };
        function format(v) {
            return d3.format(".2n")(v);
        }
        const nodes = graph.nodes.length;
        const graph2 = getGraph(rawDataTmp);
        const maxVal = d3.max(graph2.nodes.map(n => n.degree));
        const n = graph2.nodes.find(n => n.degree == maxVal);
        let i = 0;
        const nodesToBeVisited = [n];
        while (nodesToBeVisited.length) {
            let el = null;
            do {
                el = nodesToBeVisited.pop();
            } while (el.visited && nodesToBeVisited.length);
            if (!el)
                break;
            el.visited = true;
            const neighbors = rawDataTmp[el.id];
            i++;
            const neighborsToVisit = neighbors.map(e => graph2.nodes.find(n => n.id == e)).filter(e => !e.visited);
            nodesToBeVisited.push(...neighborsToVisit);
        }
        const averageDegree = avg(graph.nodes.map(n => n.degree));
        const averageClusteringCoefficient = avg(graph.nodes.map(n => n.clusteringCoefficient));
        const nonInfectedNodes = graph.nodes.filter(n => n.group !== INFECTED);
        const infectedNodes = graph.nodes.filter(n => n.group === INFECTED);
        return [
            { label: 'Iteration', val: iteration },
            { label: 'Number of nodes', val: nodes },
            { label: 'Giant component size', val: i },
            { label: 'Avg degree', val: format(averageDegree) },
            { label: 'Avg clustering coefficient', val: format(averageClusteringCoefficient) },
            { label: 'Non infected nodes', val: nonInfectedNodes.length },
            { label: 'Infected nodes', val: infectedNodes.length }
        ];
    }

    function cleanContagion() {
        graph.nodes.filter(n => n.group == INFECTED).forEach(n => n.group = NORMAL);
    }

    function startContagion() {
        stop();
        cleanContagion();
        cleanAttack();
        status = CONTAGION;
        const options = getOptions();
        const payoffs = { [NORMAL]: options.payoff1, [INFECTED]: options.payoff2 };
        let infectedNodes = chooseNodes(options.attackParameter, options.k);
        infectedNodes.forEach(n => n.group = INFECTED);
        contagionTimer = d3.interval(function () {
            iteration++;
            draw();
            updateContagion(payoffs);
        }, +options.speed, d3.now());
    }

    function stop() {
        if (attackTimer)
            attackTimer.stop();
        if (contagionTimer)
            contagionTimer.stop();
        status = WAITING;
        draw();
    }

    function updateContagion(payoffs) {
        graph.nodes.forEach(n => {
            const neighbors = graph.links.filter(l => l.source == n).map(l => l.target);
            const nonInfectedNeighbors = neighbors.filter(l => l.group == NORMAL);
            const infectedNeighbors = neighbors.filter(l => l.group == INFECTED);
            const nonInfectionScore = nonInfectedNeighbors.length * payoffs[NORMAL];
            const infectionScore = infectedNeighbors.length * payoffs[INFECTED];
            n.infected = nonInfectionScore < infectionScore;
        });
        graph.nodes.forEach(n => {
            n.group = n.infected ? INFECTED : NORMAL;
            n.infect = false;
        });
    }

    function loadEvents() {
        const buttons = document.querySelectorAll('button');
        buttons.forEach(b => b.addEventListener('click', () => {
            const id = b.id;
            window[id]();
        }));
    }

</script>